import { test, expect } from '@playwright/test';

/**
 * Vercel Preview Environment Debugging Test Suite
 *
 * This comprehensive test suite is designed to debug authentication issues
 * in the Vercel preview environment where tests fail to find authentication elements.
 */

test.describe('Vercel Preview Environment Debugging', () => {
  test.beforeEach(async ({ page }) => {
    // Enable console logging capture
    const consoleLogs: string[] = [];
    const errorLogs: string[] = [];
    const networkErrors: string[] = [];

    page.on('console', msg => {
      const text = msg.text();
      if (msg.type() === 'error') {
        errorLogs.push(`CONSOLE ERROR: ${text}`);
      } else if (msg.type() === 'warning') {
        errorLogs.push(`CONSOLE WARN: ${text}`);
      } else {
        consoleLogs.push(`CONSOLE: ${text}`);
      }
    });

    page.on('pageerror', error => {
      errorLogs.push(`PAGE ERROR: ${error.message}`);
    });

    page.on('requestfailed', request => {
      networkErrors.push(`NETWORK FAILED: ${request.method()} ${request.url()} - ${request.failure()?.errorText}`);
    });

    // Store logs in page context for access in tests
    await page.addInitScript(() => {
      (window as any).testLogs = { console: [], errors: [], network: [] };
    });

    // Clear any existing auth state
    await page.context().clearCookies();
    await page.context().clearPermissions();
  });

  test('comprehensive environment detection and debug analysis', async ({ page }) => {
    console.log('üöÄ Starting comprehensive debug analysis...');

    // Navigate to the application
    await page.goto('/');
    console.log(`üìç Navigated to: ${page.url()}`);

    // Wait for initial page load
    await page.waitForLoadState('networkidle');
    console.log('‚úÖ Page load completed (networkidle)');

    // === ENVIRONMENT DETECTION ===
    const environmentInfo = await page.evaluate(() => {
      return {
        // Basic page info
        url: window.location.href,
        hostname: window.location.hostname,
        pathname: window.location.pathname,
        search: window.location.search,
        userAgent: navigator.userAgent,
        title: document.title,

        // Environment variables detection
        isVitestTest: (import.meta.env as any).VITEST === 'true',
        isJestTest: (import.meta.env as any).JEST === 'true',
        isProduction: (import.meta.env as any).PROD === true,
        isDevelopment: (import.meta.env as any).DEV === true,
        mode: (import.meta.env as any).MODE,

        // Test mode detection
        hasTestModeParam: window.location.search.includes('test-mode=true'),
        testModeAttribute: document.body.getAttribute('data-test-mode'),
        viteModeWindow: (window as any).VITE_TEST_MODE,

        // Browser/E2E detection
        isPlaywright: navigator.userAgent.includes('Playwright'),
        isHeadlessChrome: navigator.userAgent.includes('HeadlessChrome'),
        hasWebdriver: window.navigator.webdriver === true,
        hasPlaywrightGlobal: typeof (window as any).__playwright !== 'undefined',
        hasE2EGlobal: typeof (window as any).__e2e_test !== 'undefined',

        // Vercel detection
        isVercelApp: window.location.hostname.includes('vercel.app'),
        isGitBranch: window.location.hostname.includes('-git-'),

        // Auth context detection
        hasSupabase: typeof (window as any).supabase !== 'undefined',
        supabaseClientPresent: typeof (window as any).supabaseClient !== 'undefined',

        // DOM state
        bodyContent: document.body.innerText.substring(0, 1000),
        bodyDataAttributes: Array.from(document.body.attributes).map(attr => `${attr.name}="${attr.value}"`),
        headElements: Array.from(document.head.children).map(el => `<${el.tagName.toLowerCase()}${el.id ? ` id="${el.id}"` : ''}>`),
      };
    });

    console.log('üåç ENVIRONMENT INFO:');
    console.log(JSON.stringify(environmentInfo, null, 2));

    // === AUTH FLOW DETECTION ===
    console.log('üîê Analyzing authentication flow...');

    // Wait a moment for React to initialize
    await page.waitForTimeout(3000);

    const authFlowState = await page.evaluate(() => {
      // Check for all possible auth-related elements
      const authElements = {
        // Loading states
        authLoading: !!document.querySelector('[data-testid="auth-loading"]'),
        loadingSpinner: !!document.querySelector('[data-testid="loading-spinner"]'),
        loadingSpinnerIcon: !!document.querySelector('[data-testid="loading-spinner-icon"]'),

        // Auth form elements
        authFormSubtitle: !!document.querySelector('[data-testid="auth-form-subtitle"]'),
        emailInput: !!document.querySelector('[data-testid="email-input"]'),
        passwordInput: !!document.querySelector('[data-testid="password-input"]'),
        submitButton: !!document.querySelector('[data-testid="submit-button"]'),
        toggleAuthMode: !!document.querySelector('[data-testid="toggle-auth-mode"]'),
        googleLogin: !!document.querySelector('[data-testid="google-login-button"]'),
        githubLogin: !!document.querySelector('[data-testid="github-login-button"]'),
        errorMessage: !!document.querySelector('[data-testid="error-message"]'),

        // Protected content
        protectedContent: !!document.querySelector('[data-testid="protected-content"]'),
        flashcardApp: !!document.querySelector('[data-testid="flashcard-app"]'),

        // Text content analysis
        hasSignInText: document.body.innerText.includes('Sign in to continue'),
        hasCreateAccountText: document.body.innerText.includes('Create your account'),
        hasModeSelectionText: document.body.innerText.includes('Mode Selection'),
        hasItalianFlashcardsText: document.body.innerText.includes('Italian Flashcards'),
        hasAuthLoadingText: document.body.innerText.includes('Checking authentication'),

        // Get actual auth form subtitle text if it exists
        authFormSubtitleText: document.querySelector('[data-testid="auth-form-subtitle"]')?.textContent || null,

        // Check for React components by class names
        hasFramerMotionClasses: !!document.querySelector('[class*="motion"]'),
        hasTailwindClasses: !!document.querySelector('[class*="bg-"]'),
      };

      // Get all data-testid elements present on the page
      const allTestIds = Array.from(document.querySelectorAll('[data-testid]')).map(el => {
        return {
          testId: el.getAttribute('data-testid'),
          tagName: el.tagName,
          visible: !!(el as HTMLElement).offsetWidth && !!(el as HTMLElement).offsetHeight,
          textContent: el.textContent?.substring(0, 100) || '',
          className: el.className || ''
        };
      });

      // Get all visible elements with text content
      const visibleElements = Array.from(document.querySelectorAll('*')).filter(el => {
        const htmlEl = el as HTMLElement;
        return htmlEl.offsetWidth > 0 && htmlEl.offsetHeight > 0 && htmlEl.textContent?.trim();
      }).slice(0, 20).map(el => ({
        tagName: el.tagName,
        textContent: el.textContent?.substring(0, 50) || '',
        className: el.className || '',
        id: el.id || ''
      }));

      return {
        authElements,
        allTestIds,
        visibleElements,
        totalElements: document.querySelectorAll('*').length,
        totalTestIdElements: document.querySelectorAll('[data-testid]').length
      };
    });

    console.log('üîê AUTH FLOW STATE:');
    console.log(JSON.stringify(authFlowState, null, 2));

    // === NETWORK ANALYSIS ===
    console.log('üåê Analyzing network requests...');

    // Check for Supabase API calls
    const supabaseRequests = await page.evaluate(() => {
      // Look for any indication of Supabase requests in the network tab
      return {
        hasSupabaseInDOM: document.body.innerHTML.includes('supabase'),
        hasSupabaseRequests: (window as any).supabaseRequestsDetected || false
      };
    });

    console.log('üåê NETWORK ANALYSIS:');
    console.log(JSON.stringify(supabaseRequests, null, 2));

    // === SCREENSHOT CAPTURE ===
    console.log('üì∏ Taking debug screenshots...');

    await page.screenshot({
      path: 'test-results/vercel-debug-full-page.png',
      fullPage: true
    });

    await page.screenshot({
      path: 'test-results/vercel-debug-viewport.png',
      fullPage: false
    });

    // === ELEMENT EXISTENCE VERIFICATION ===
    console.log('üîç Verifying specific element existence...');

    // Test different ways to find the auth form subtitle
    const elementDetectionResults = await page.evaluate(() => {
      const results: any = {};

      // Method 1: Direct data-testid query
      results.directQuery = !!document.querySelector('[data-testid="auth-form-subtitle"]');

      // Method 2: Text content search
      results.byTextContent = Array.from(document.querySelectorAll('*')).some(el =>
        el.textContent?.includes('Sign in to continue') || el.textContent?.includes('Create your account')
      );

      // Method 3: Check for any p tags with the text
      results.byPTag = Array.from(document.querySelectorAll('p')).some(p =>
        p.textContent?.includes('Sign in to continue') || p.textContent?.includes('Create your account')
      );

      // Method 4: Check for elements with specific classes
      results.byTailwindClasses = !!document.querySelector('p.text-gray-600');

      // Method 5: Wait for dynamic content
      results.hasReactRoot = !!document.querySelector('#root');
      results.hasAppContent = document.querySelector('#root')?.innerHTML?.length || 0;

      return results;
    });

    console.log('üîç ELEMENT DETECTION RESULTS:');
    console.log(JSON.stringify(elementDetectionResults, null, 2));

    // === FINAL VERIFICATION ===
    console.log('‚úÖ Running final verification checks...');

    // Check if the page is actually working by looking for any interactive elements
    const hasInteractiveElements = await page.locator('button, input, a, [role="button"]').count();
    console.log(`üìä Interactive elements found: ${hasInteractiveElements}`);

    // Check if we're stuck in a loading state
    const isStuckLoading = await page.locator('[data-testid="auth-loading"]').isVisible().catch(() => false);
    console.log(`‚è≥ Stuck in loading state: ${isStuckLoading}`);

    // Check for error states
    const hasErrors = await page.locator('[data-testid="error-message"]').isVisible().catch(() => false);
    console.log(`‚ùå Has error messages: ${hasErrors}`);

    // === ASSERTIONS FOR TEST MONITORING ===
    // These assertions help identify what's actually happening

    if (authFlowState.authElements.protectedContent) {
      console.log('‚úÖ DETECTED: User is authenticated - protected content is visible');
      expect(authFlowState.authElements.protectedContent).toBe(true);
    } else if (authFlowState.authElements.authLoading) {
      console.log('‚è≥ DETECTED: Authentication is loading');
      expect(authFlowState.authElements.authLoading).toBe(true);
    } else if (authFlowState.authElements.authFormSubtitle) {
      console.log('üîê DETECTED: Login form is visible');
      expect(authFlowState.authElements.authFormSubtitle).toBe(true);
    } else {
      console.log('‚ùå PROBLEM: No expected authentication state detected');
      console.log('üîç Available elements:', authFlowState.allTestIds.map(el => el.testId));
      console.log('üìã Page content preview:', environmentInfo.bodyContent.substring(0, 200));

      // This assertion will fail and show us what's actually on the page
      expect.soft(authFlowState.authElements.authFormSubtitle).toBe(true);
      expect.soft(authFlowState.authElements.authLoading).toBe(true);
      expect.soft(authFlowState.authElements.protectedContent).toBe(true);
    }

    // Always pass the test but provide debugging info
    expect(page.url()).toContain('http');
  });

  test('test specific preview URL pattern with bypass token', async ({ page }) => {
    console.log('üîó Testing specific preview URL pattern...');

    const previewUrl = process.env.PLAYWRIGHT_TEST_BASE_URL || page.url();
    console.log(`üéØ Testing URL: ${previewUrl}`);

    // Test with different query parameters that might affect behavior
    const testUrls = [
      previewUrl,
      `${previewUrl}?test-mode=true`,
      `${previewUrl}?debug=true`,
      `${previewUrl}?e2e-test=true`
    ];

    for (const testUrl of testUrls) {
      console.log(`üß™ Testing URL: ${testUrl}`);

      await page.goto(testUrl);
      await page.waitForLoadState('networkidle');
      await page.waitForTimeout(2000);

      const hasAuthForm = await page.locator('[data-testid="auth-form-subtitle"]').isVisible().catch(() => false);
      const hasProtectedContent = await page.locator('[data-testid="protected-content"]').isVisible().catch(() => false);
      const hasAuthLoading = await page.locator('[data-testid="auth-loading"]').isVisible().catch(() => false);

      console.log(`üìä URL: ${testUrl}`);
      console.log(`   - Auth form visible: ${hasAuthForm}`);
      console.log(`   - Protected content visible: ${hasProtectedContent}`);
      console.log(`   - Auth loading visible: ${hasAuthLoading}`);

      // Take a screenshot for this specific URL
      const urlSuffix = new URL(testUrl).search.replace(/[^a-zA-Z0-9]/g, '-') || 'default';
      await page.screenshot({
        path: `test-results/url-test-${urlSuffix}.png`,
        fullPage: true
      });
    }

    expect(testUrls.length).toBeGreaterThan(0);
  });

  test('wait for auth state resolution with timeout debugging', async ({ page }) => {
    console.log('‚è±Ô∏è Testing auth state resolution with extended timeouts...');

    await page.goto('/');
    console.log('üìç Page loaded, starting auth state monitoring...');

    // Monitor auth state changes over time
    const authStateHistory: any[] = [];

    for (let i = 0; i < 10; i++) {
      await page.waitForTimeout(1000);

      const state = await page.evaluate(() => {
        return {
          timestamp: Date.now(),
          hasAuthLoading: !!document.querySelector('[data-testid="auth-loading"]'),
          hasAuthForm: !!document.querySelector('[data-testid="auth-form-subtitle"]'),
          hasProtectedContent: !!document.querySelector('[data-testid="protected-content"]'),
          bodyText: document.body.innerText.substring(0, 100),
          testIds: Array.from(document.querySelectorAll('[data-testid]')).map(el => el.getAttribute('data-testid'))
        };
      });

      authStateHistory.push({ iteration: i + 1, ...state });
      console.log(`‚è±Ô∏è Iteration ${i + 1}:`, JSON.stringify(state, null, 2));

      // If we found a stable state, break early
      if (state.hasAuthForm || state.hasProtectedContent) {
        console.log(`‚úÖ Stable auth state found at iteration ${i + 1}`);
        break;
      }
    }

    console.log('üìà AUTH STATE HISTORY:');
    console.log(JSON.stringify(authStateHistory, null, 2));

    // Final state verification
    const finalState = authStateHistory[authStateHistory.length - 1];
    const hasAnyAuthState = finalState.hasAuthLoading || finalState.hasAuthForm || finalState.hasProtectedContent;

    expect(hasAnyAuthState).toBe(true);
  });

  test('manual element search and DOM structure analysis', async ({ page }) => {
    console.log('üîç Performing manual element search and DOM analysis...');

    await page.goto('/');
    await page.waitForLoadState('networkidle');
    await page.waitForTimeout(3000);

    // Comprehensive DOM structure analysis
    const domAnalysis = await page.evaluate(() => {
      const analysis: any = {};

      // React Root Analysis
      const root = document.querySelector('#root');
      analysis.hasRoot = !!root;
      analysis.rootContent = root?.innerHTML?.substring(0, 500) || 'No root found';
      analysis.rootChildren = root ? Array.from(root.children).map(child => child.tagName) : [];

      // Auth-related element search
      analysis.authRelatedElements = [];

      // Search for elements containing auth-related text
      const allElements = Array.from(document.querySelectorAll('*'));
      allElements.forEach(el => {
        const text = el.textContent?.toLowerCase() || '';
        if (text.includes('sign in') || text.includes('login') || text.includes('auth') || text.includes('continue')) {
          analysis.authRelatedElements.push({
            tagName: el.tagName,
            textContent: el.textContent?.substring(0, 100),
            className: el.className,
            id: el.id,
            testId: el.getAttribute('data-testid'),
            attributes: Array.from(el.attributes).map(attr => `${attr.name}="${attr.value}"`)
          });
        }
      });

      // Search for all form elements
      analysis.formElements = Array.from(document.querySelectorAll('form, input, button')).map(el => ({
        tagName: el.tagName,
        type: el.getAttribute('type'),
        testId: el.getAttribute('data-testid'),
        className: el.className,
        textContent: el.textContent?.substring(0, 50)
      }));

      // Search for loading indicators
      analysis.loadingElements = Array.from(document.querySelectorAll('[class*="loading"], [class*="spinner"], svg')).map(el => ({
        tagName: el.tagName,
        className: el.className,
        testId: el.getAttribute('data-testid'),
        ariaLabel: el.getAttribute('aria-label')
      }));

      // Check for Framer Motion elements
      analysis.motionElements = Array.from(document.querySelectorAll('[style*="transform"], [class*="motion"]')).length;

      // Check for Tailwind classes
      analysis.tailwindElements = Array.from(document.querySelectorAll('[class*="bg-"], [class*="text-"], [class*="flex"]')).length;

      return analysis;
    });

    console.log('üîç DOM STRUCTURE ANALYSIS:');
    console.log(JSON.stringify(domAnalysis, null, 2));

    // Screenshot with element highlighting
    await page.addStyleTag({
      content: `
        [data-testid] {
          outline: 2px solid red !important;
          outline-offset: 2px !important;
        }
        [data-testid]:before {
          content: attr(data-testid);
          position: absolute;
          background: red;
          color: white;
          font-size: 10px;
          padding: 2px;
          z-index: 9999;
        }
      `
    });

    await page.screenshot({
      path: 'test-results/dom-analysis-with-highlights.png',
      fullPage: true
    });

    expect(domAnalysis.hasRoot).toBe(true);
  });

  test.afterEach(async ({ page }) => {
    // Capture final page state for debugging
    const finalState = await page.evaluate(() => ({
      url: window.location.href,
      title: document.title,
      bodyLength: document.body.innerHTML.length,
      testIdCount: document.querySelectorAll('[data-testid]').length
    }));

    console.log('üèÅ FINAL PAGE STATE:', JSON.stringify(finalState, null, 2));
  });
});